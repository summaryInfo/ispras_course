#include "ofile.hpp"
#include "util.hpp"
#include "insn.hpp"

#include <iostream>
#include <fstream>

void disas_code(const object_file &obj, std::ostream &ostr, const function &fn, std::vector<uint8_t> &stab) {

    /* First, generate labels */

    std::map<uint32_t, uint32_t> labels;
    bool wide{};
    std::size_t labn{};

    for (auto op = fn.code.begin(); op < fn.code.end(); ) {
        switch(insns[*op++].iclass) {
        case ins_return:
        case ins_undef:
        case ins_plain:
            break;
        case ins_jump: {
            int16_t disp = util::read_im<int16_t>(op, wide);
            labels.emplace(op - fn.code.begin() + disp, labn++);
        } break;
        case ins_call:
        case ins_local:
        case ins_global:
            util::read_im<int16_t>(op, wide);
            break;
        case ins_const:
            switch(op[-1]) {
            case op_ldi_i:
            case op_ldi_l:
                util::read_im<int16_t>(op, wide);
                break;
            case op_ldc_i:
                op += sizeof(int32_t);
                break;
            case op_ldc_l:
                op += sizeof(int64_t);
                break;
            case op_ldc_f:
                op += sizeof(float);
                break;
            case op_ldc_d:
                op += sizeof(double);
                break;
            default:
                throw std::logic_error("Oops 2");
            }
            break;
        case ins_wide:
            wide = true;
        }
    }

    /* Then emit code itself */

    for (auto op = fn.code.begin(); op < fn.code.end(); ) {
        auto &insn = insns[*op++];

        if (insn.iclass == ins_wide) {
            wide = true;
            continue;
        }

        const auto &lab = labels.find(op - 1 - fn.code.begin());
        if (lab != labels.end()) {
            /* Emit label if some instruction references current address
             * NOTE: Jumps to the middle of instruction emits invalid labels
             *       and cannot be generated by xsas */
            ostr << "L" << lab->second << ":" << std::endl;
        }
        /* Instruction mnemonic */
        ostr << "\t" << insn.name;

        switch(insn.iclass) {
        case ins_undef:
        case ins_return:
        case ins_plain:
            /* Don't need to do anything for plain insns */
            break;
        case ins_jump: {
            int16_t disp = util::read_im<int16_t>(op, wide);
            ostr << " L" << labels[op - fn.code.begin() + disp];
        } break;
        case ins_call: {
            uint16_t disp = util::read_im<uint16_t, uint8_t>(op, wide);
            ostr << " " << &stab[obj.functions[disp].name];
        } break;
        case ins_local: {
            int16_t disp = util::read_im<int16_t>(op, wide);
            if (disp < 0) {
                ostr << " loc" << -(1 + disp);
            } else {
                ostr << " par" << disp;
            }
        } break;
        case ins_global: {
            uint16_t disp = util::read_im<uint16_t, uint8_t>(op, wide);
            ostr << " " << &stab[obj.globals[disp].name];
        } break;
        case ins_const:
            switch(op[-1]) {
            case op_ldi_i:
            case op_ldi_l: {
                int32_t cons = util::read_im<int16_t>(op, wide);
                ostr << " $" << cons;
            } break;
            case op_ldc_i: {
                int32_t cons = util::read_next<int32_t>(op);
                ostr << " $" << cons;
            } break;
            case op_ldc_l: {
                auto cons = util::read_next<int64_t>(op);
                ostr << " $" << cons;
            } break;
            case op_ldc_f: {
                auto cons = util::read_next<float>(op);
                ostr << " $" << cons;
            } break;
            case op_ldc_d: {
                auto cons = util::read_next<double>(op);
                ostr << " $" << cons;
            } break;
            }
            [[fallthrough]];
        case ins_wide:
            break;
        }

        ostr << std::endl;
    }
}

void disas_object(const object_file &obj, const std::string &file, std::ostream &ostr) {
    auto stab = obj.make_strtab();

    /* 1. Globals */

    for (const auto &gl : obj.globals) {
        ostr << ".global " << typid_to_type(gl.type) << " " << &stab[gl.name];
        if (gl.flags & gf_init) {
            const auto ptr = reinterpret_cast<const uint8_t*>(&gl.init_value);
            switch(gl.type) {
            case 'i': ostr << " " << util::read_at<int32_t>(ptr); break;
            case 'l': ostr << " " << util::read_at<int64_t>(ptr); break;
            case 'f': ostr << " " << util::read_at<float>(ptr); break;
            case 'd': ostr << " " << util::read_at<double>(ptr); break;
            default:
                throw std::logic_error("Oops 3");
            }
        }
        ostr << std::endl;
    }

    /* 2. Functions */

    for (const auto &fn : obj.functions) {
        /* Function itself */
        ostr << ".function " << typid_to_type(fn.signature.back()) << " " << &stab[fn.name] << std::endl;
        auto p0 = fn.signature.find('(');
        auto p1 = fn.signature.find(')');
        if (p0 == fn.signature.npos || p1 == fn.signature.npos || p0 >= p1)
            throw std::logic_error("Oops 4");

        /* Parameters */
        for(auto pos = p1; --pos > p0;) {
            ostr << ".param "
                      << typid_to_type(fn.signature[pos])
                      << " par"
                      << p1 - pos - 1
                      << std::endl;
        }
        /* Local variables */
        std::size_t i = 0;
        for (auto c : fn.locals) {
            ostr << ".local "
                      << typid_to_type(c)
                      << " loc"
                      << i++
                      << std::endl;
        }

        /* Code */
        disas_code(obj, ostr, fn, stab);
    }
}

int main(int argc, char *argv[]) {

    if ((argc > 1 && !std::strcmp("-h", argv[1])) || argc < 2) {
        std::cout << "Usage:\n" << std::endl;
        std::cout << "\t" << argv[0] << " <infile>.xso [<outfile>]" << std::endl;
        std::cout << "Default value of <outfile> is <infile>.xs" << std::endl;
        return 0;
    }

    std::ifstream str(argv[1], std::ios::binary | std::ios::in);
    if (!str.is_open()) {
        std::cerr << "Cannot open input file \"" << argv[1] << '"' << std::endl;
        return EXIT_FAILURE;
    }
    object_file obj;
    obj.read(str);

    std::string outfile = argc < 3 ? util::swap_ext(argv[1], XSO_EXT, XS_EXT) : argv[2];
    std::ofstream outstr(outfile, std::ios::out | std::ios::trunc);
    if (!outstr.is_open()) {
        std::cerr << "Cannot open output file \"" << outfile << '"' << std::endl;
        return EXIT_FAILURE;
    }
    disas_object(obj, outfile, outstr);

    return 0;
}
