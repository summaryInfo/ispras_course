#include "ofile.hpp"
#include "util.hpp"
#include "insn.hpp"

#include <iostream>
#include <fstream>
#include <sstream>

template<typename It>
std::string string_of_type(char type, It &ptr) {
    std::stringstream ss;
    switch (type) {
    case 'i': ss << util::read_next<int32_t>(ptr); break;
    case 'l': ss << util::read_next<int64_t>(ptr); break;
    case 'f': ss << util::read_next<float>(ptr); break;
    case 'd': ss << util::read_next<double>(ptr); break;
    default:
        throw std::logic_error("Oops, unknown type");
    }
    return ss.str();
}

void disas_code(const object_file &obj, std::ostream &ostr, const function &fn, std::vector<uint8_t> &stab) {

    /* First, generate labels */

    std::map<uint32_t, uint32_t> labels;
    bool wide{};
    std::size_t labn{};

    for (auto op = fn.code.begin(); op < fn.code.end(); ) {
        uint8_t cmd = *op++;
        switch(insns[cmd].iclass) {
        case ins_return:
        case ins_undef:
        case ins_plain:
            break;
        case ins_jump: {
            int16_t disp = util::read_im<int16_t>(op, wide);
            labels.emplace(op - fn.code.begin() + disp, labn++);
        } break;
        case ins_call:
        case ins_local:
        case ins_global:
            util::read_im<int16_t>(op, wide);
            break;
        case ins_const:
            switch(cmd & ~cmd_type_mask) {
            case op_ldi_i:
                util::read_im<int16_t>(op, wide);
                break;
            case op_ldc_i:
                op += type_size(insns[cmd].type);
                break;
            default:
                throw std::logic_error("Oops, bug");
            }
            break;
        case ins_wide:
            wide = true;
        }
    }

    /* Then emit code itself */

    for (auto op = fn.code.begin(); op < fn.code.end(); ) {
        auto &insn = insns[*op++];

        if (insn.iclass == ins_wide) {
            wide = true;
            continue;
        }

        const auto &lab = labels.find(op - 1 - fn.code.begin());
        if (lab != labels.end()) {
            /* Emit label if some instruction references current address
             * NOTE: Jumps to the middle of instruction emits invalid labels
             *       and cannot be generated by xsas */
            ostr << "L" << lab->second << ":" << std::endl;
        }
        /* Instruction mnemonic */
        ostr << "\t" << insn.name;

        switch(insn.iclass) {
        case ins_undef:
        case ins_return:
        case ins_plain:
            /* Don't need to do anything for plain insns */
            break;
        case ins_jump: {
            int16_t disp = util::read_im<int16_t>(op, wide);
            ostr << " L" << labels[op - fn.code.begin() + disp];
        } break;
        case ins_call: {
            uint16_t disp = util::read_im<uint16_t, uint8_t>(op, wide);
            ostr << " " << &stab[obj.functions[disp].name];
        } break;
        case ins_local: {
            int16_t disp = util::read_im<int16_t>(op, wide);
            if (disp < 0) {
                ostr << " loc" << -(1 + disp);
            } else {
                ostr << " par" << disp;
            }
        } break;
        case ins_global: {
            uint16_t disp = util::read_im<uint16_t, uint8_t>(op, wide);
            ostr << " " << &stab[obj.globals[disp].name];
        } break;
        case ins_const:
            switch(op[-1] & ~cmd_type_mask) {
            case op_ldi_i:
                ostr << " $" << util::read_im<int16_t>(op, wide);
                break;
            case op_ldc_i:
                ostr << " $" << string_of_type(insn.type, op);
                break;
            default:
                throw std::logic_error("Oops, bug");
            }
            [[fallthrough]];
        case ins_wide:
            break;
        }

        ostr << std::endl;
    }
}

void disas_object(const object_file &obj, const std::string &file, std::ostream &ostr) {
    auto stab = obj.make_strtab();

    /* 1. Globals */

    for (const auto &gl : obj.globals) {
        ostr << ".global " << typid_to_type(gl.type) << " " << &stab[gl.name];
        if (gl.flags & gf_init) {
            auto ptr = reinterpret_cast<const uint8_t*>(&gl.init_value);
            ostr << " " << string_of_type(gl.type, ptr);
        }
        ostr << std::endl;
    }

    /* 2. Functions */

    for (const auto &fn : obj.functions) {
        /* Function itself */
        ostr << ".function " << typid_to_type(fn.signature.back()) << " " << &stab[fn.name] << std::endl;
        auto p0 = fn.signature.find('(');
        auto p1 = fn.signature.find(')');
        if (p0 == fn.signature.npos || p1 == fn.signature.npos || p0 >= p1)
            throw std::logic_error("Oops 4");

        std::size_t i = 0;

        /* Parameters */
        for(auto pos = p1; --pos > p0;) {
            ostr << ".param "
                      << typid_to_type(fn.signature[pos])
                      << " par"
                      << i
                      << std::endl;
            i += type_size(fn.signature[pos]) / sizeof(int32_t);
        }
        /* Local variables */
        i = 0;
        for (auto c : fn.locals) {
            ostr << ".local "
                      << typid_to_type(c)
                      << " loc"
                      << i
                      << std::endl;
            i += type_size(c) / sizeof(int32_t);
        }

        /* Code */
        disas_code(obj, ostr, fn, stab);
    }
}

int main(int argc, char *argv[]) {

    if ((argc > 1 && !std::strcmp("-h", argv[1])) || argc < 2) {
        std::cout << "Usage:\n" << std::endl;
        std::cout << "\t" << argv[0] << " <infile>.xso [<outfile>]" << std::endl;
        std::cout << "Default value of <outfile> is <infile>.xs" << std::endl;
        return 0;
    }

    std::ifstream str(argv[1], std::ios::binary | std::ios::in);
    if (!str.is_open()) {
        std::cerr << "Cannot open input file \"" << argv[1] << '"' << std::endl;
        return EXIT_FAILURE;
    }
    object_file obj;
    obj.read(str);

    std::string outfile = argc < 3 ? util::swap_ext(argv[1], XSO_EXT, XS_EXT) : argv[2];
    std::ofstream outstr(outfile, std::ios::out | std::ios::trunc);
    if (!outstr.is_open()) {
        std::cerr << "Cannot open output file \"" << outfile << '"' << std::endl;
        return EXIT_FAILURE;
    }
    disas_object(obj, outfile, outstr);

    return 0;
}
